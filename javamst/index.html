<!-- build time:Wed Feb 05 2020 17:40:41 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0"><link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.6.0",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="keywords" content="Java基础,Java常见面试题"><meta property="og:type" content="article"><meta property="og:title" content="Java常见面试题"><meta property="og:url" content="https://www.lee1224.com/javamst/index.html"><meta property="og:site_name" content="一只老菜鸡"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111093702840.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111101659618.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111102304261.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111114653964.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111014345892.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111020910764.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111025917752.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111034905630.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111035107425.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111035736601.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111040013863.png"><meta property="og:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111041158046.png"><meta property="og:updated_time" content="2019-11-14T06:17:46.377Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java常见面试题"><meta name="twitter:image" content="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111093702840.png"><link rel="canonical" href="https://www.lee1224.com/javamst/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>Java常见面试题 | 一只老菜鸡</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-139716604-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-139716604-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?488033ebdd2b3fb2de16b61887ca888d";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"><a href="https://github.com/dp1224"><img style="position:absolute;top:0;right:0;border:0" src="https://img.lee1224.com/githubRibbons/onuse.png" alt="Fork me on GitHub"></a></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">一只老菜鸡</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">学习、记录、分享</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RwMTIyNA==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#222;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></span><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lee1224.com/javamst/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="黎雁鹏"><meta itemprop="description" content=""><meta itemprop="image" content="https://img.lee1224.com/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一只老菜鸡"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">Java常见面试题</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-11 09:33:08" itemprop="dateCreated datePublished" datetime="2019-11-11T09:33:08+08:00">2019-11-11</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-14 14:17:46" itemprop="dateModified" datetime="2019-11-14T14:17:46+08:00">2019-11-14</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111093702840.png" alt=""></p><a id="more"></a><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1846487437001924" data-ad-slot="6405014372"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h1 id="一、Java基础部分"><a href="#一、Java基础部分" class="headerlink" title="一、Java基础部分"></a>一、Java基础部分</h1><h2 id="1-基本数据类型以及字节数"><a href="#1-基本数据类型以及字节数" class="headerlink" title="1.基本数据类型以及字节数"></a>1.基本数据类型以及字节数</h2><pre><code>四类八种

整型   -- 默认 是 int
    byte  字节   1字节       [-128,127]
    short   短整型   2字节
    int    整型   4字节
    long  长整型  8字节      数字后需要添加l或者L
浮点型  -- 默认 是 double 无限接近于一个数
    float  单精度   4字节      数字后需要添加f或者F
    double  双精度   8字节
字符型  -- 默认 是 &apos;\u0000&apos;
    char  字符型   2字节   放在单引号中，只有一个字符 &apos;a&apos;
布尔型  -- 默认 是  false
    boolean  1字节   true/false
</code></pre><h2 id="2-标识符命名规则"><a href="#2-标识符命名规则" class="headerlink" title="2.标识符命名规则"></a>2.标识符命名规则</h2><pre><code>标识符的含义：
是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。
命名规则：（硬性要求）
标识符可以包含英文字母，0-9的数字，$以及_
标识符不能以数字开头
标识符不是关键字
命名规范：（非硬性要求）
类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。
变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。
方法名规范：同变量名。
</code></pre><blockquote class="blockquote-center"><p><a class="btn" href="https://www.lee1224.com/javammgf/"><i class="fa fa-fas fa-link"></i>点击进入《Java命名规范》</a></p></blockquote><h2 id="3-方法重写和重载的区别"><a href="#3-方法重写和重载的区别" class="headerlink" title="3.方法重写和重载的区别"></a>3.方法重写和重载的区别</h2><ul><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</li><li>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</li><li>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</li><li>在面向对象原则里，重写意味着可以重写任何现有方法。</li></ul><h3 id="重写-Override-方法的重写规则"><a href="#重写-Override-方法的重写规则" class="headerlink" title="重写(Override)方法的重写规则"></a>重写(Override)方法的重写规则</h3><ul><li>参数列表必须完全与被重写方法的相同。</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li><li>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</li></ul><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h3><ul><li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li><li>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li><li>最常用的地方就是构造器的重载。</li></ul><h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则:"></a>重载规则:</h4><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111101659618.png" alt=""></p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1846487437001924" data-ad-slot="6405014372"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</strong><br><strong>(1)</strong>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。<br><strong>(2)</strong>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。<br><strong>(3)</strong>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p><h2 id="4-面向对象的特性，以及你是怎么理解的？-面向对象三大特性，五大基本原则"><a href="#4-面向对象的特性，以及你是怎么理解的？-面向对象三大特性，五大基本原则" class="headerlink" title="4.面向对象的特性，以及你是怎么理解的？(面向对象三大特性，五大基本原则)"></a>4.面向对象的特性，以及你是怎么理解的？(面向对象三大特性，五大基本原则)</h2><p><strong>三大特性是：封装,继承,多态</strong><br><strong>五大基本原则</strong></p><ul><li>单一职责原则SRP(Single Responsibility Principle)</li><li>开放封闭原则OCP(Open－Close Principle)</li><li>替换原则(the Liskov Substitution Principle LSP)</li><li>依赖原则(the Dependency Inversion Principle DIP)</li><li>接口分离原则(the Interface Segregation Principle ISP)</li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppeWlxaW5sb3ZleHgvYXJ0aWNsZS9kZXRhaWxzLzQ2NTkzMDUz" title="https://blog.csdn.net/jiyiqinlovexx/article/details/46593053"><i class="fa fa-fas fa-link"></i>点击进入《Java基础：面向对象三大特征、五大原则》<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG5yYWlubGwvYXJjaGl2ZS8yMDEyLzA5LzE4LzI2OTA4NDYuaHRtbA==" title="fas fa-link"><i class="fa fa-五大基本原则》"></i>点击进入《面向对象三大基本特性<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="5-访问修饰符-public、private、protected、以及不写时的区别"><a href="#5-访问修饰符-public、private、protected、以及不写时的区别" class="headerlink" title="5.访问修饰符 public、private、protected、以及不写时的区别"></a>5.访问修饰符 public、private、protected、以及不写时的区别</h2><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111102304261.png" alt=""></p><p><strong>注：<br>不写时默认为friendly(default)，默认为包内使用。</strong></p><h2 id="6-子类继承父类，静态代码块、构造代码块、构造函数的执行顺序"><a href="#6-子类继承父类，静态代码块、构造代码块、构造函数的执行顺序" class="headerlink" title="6.子类继承父类，静态代码块、构造代码块、构造函数的执行顺序"></a>6.子类继承父类，静态代码块、构造代码块、构造函数的执行顺序</h2><ul><li>1、实现父类公共的静态属性或静态的块级代码</li><li>2、实现本身的公共的静态属性<br><strong>—————————-静态初始化</strong></li><li>3、实现父类普通成员初始化（包括构造代码块）</li><li>4、执行父类的构造方法<br><strong>—————————-父类初始化</strong></li><li>5、实现子类普通成员初始化（包括构造代码块）</li><li>6、执行本身的构造函数<br><strong>—————————-子类初始化</strong></li><li>7、静态方法不执行<br><strong>补充：<br>1.当父类有多个构造函数，若子类用super(参数信息)指明调用父类有参数的构造函数，则不执行无参数的构造方法<br>2.静态代码块的定义是在类被加载进内存中的方法区的时候调用,而加载类到内存中只需要执行一次即可,所以静态代码块也是只执行一次<br>static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的,它会把读取到的类缓存起来,<br>所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</strong></li></ul><h2 id="7-amp-和-amp-amp-的区别"><a href="#7-amp-和-amp-amp-的区别" class="headerlink" title="7.&amp; 和 &amp;&amp; 的区别"></a>7.&amp; 和 &amp;&amp; 的区别</h2><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p><p>&amp;&amp;还具有<strong>短路</strong>的功能，即如果第一个表达式为false，则不再计算第二个表达式。</p><p>&amp;还可以用作按位与的运算符，两个表达式的值按二进制位展开，对应的位(bit)按值进行“与”运算，结果保留在该位上。</p><h2 id="8-什么是抽象类"><a href="#8-什么是抽象类" class="headerlink" title="8.什么是抽象类"></a>8.什么是抽象类</h2><ul><li><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p></li><li><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p></li><li><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p></li><li><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p></li><li><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ul><p><strong>声明抽象方法会造成以下两个结果：</strong></p><ul><li>如果一个类包含抽象方法，那么该类必须是抽象类。</li><li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li></ul><p><strong>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</strong></p><h2 id="9-一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？"><a href="#9-一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？" class="headerlink" title="9.一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？"></a>9.一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？</h2><p><strong>可以定义成抽象类。主要目的是不让外界创建对象。要想访问它只能通过他的子类去使用。</strong><br>这种场景更多的出现在各种工具类中，如果它的所有方法都是静态的，那么把它定义为抽象的，会从机制上防止实例化。</p><h2 id="10-abstract不能和哪些关键字共存，为什么？"><a href="#10-abstract不能和哪些关键字共存，为什么？" class="headerlink" title="10.abstract不能和哪些关键字共存，为什么？"></a>10.abstract不能和哪些关键字共存，为什么？</h2><ul><li>final。冲突。因为被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。</li><li>private。冲突。抽象类中私有的抽象方法不能被子类重写。</li><li>static。无意义。如果static可以修饰抽象方法，那就可以直接通过类名调用方法，但是抽象方法根本没有方法体，这样抽象方法运行就没意义了。</li></ul><h2 id="11-抽象类和接口的区别"><a href="#11-抽象类和接口的区别" class="headerlink" title="11.抽象类和接口的区别"></a>11.抽象类和接口的区别</h2><ul><li>在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。</li><li>一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。</li><li>实现 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。</li><li>抽象类可以有构造器，而接口不能有构造器</li><li>抽象方法可以有public、protected和default这些修饰符，接口方法默认修饰符是public。你不可以使用其它修饰符。</li><li>抽象方法比接口速度要快，接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</li><li>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。</li></ul><h2 id="12-什么是匿名内部类"><a href="#12-什么是匿名内部类" class="headerlink" title="12.什么是匿名内部类"></a>12.什么是匿名内部类</h2><ul><li>匿名内部类也就是没有名字的内部类</li><li>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</li><li>但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口</li></ul><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">new</span> 类名或者接口名() &#123;</span></span><br><span class="line"><span class="function">    重写方法();</span></span><br><span class="line"><span class="function">&#125;;</span></span><br></pre></td></tr></table></figure><p>本质：其实是继承该类或者实现接口的子类匿名对象</p><p>这也就是下例中，可以直接使用<br>new Inner() {}.show(); 的原因 == 子类对象.show();<br></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Inner</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Outer</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">               System.<span class="keyword">out</span>.println(<span class="string">"HelloWorld"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;.show();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>  &#123;</span><br><span class="line">          Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">          o.method();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="13-号和equals方法的区别"><a href="#13-号和equals方法的区别" class="headerlink" title="13.==号和equals方法的区别"></a>13.==号和equals方法的区别</h2><p><strong>== 的作用：</strong></p><ul><li>基本类型：比较的就是值是否相同</li><li>引用类型：比较的就是地址值是否相同<br><strong>equals 的作用:</strong></li><li>引用类型：默认情况下，比较的是地址值。<br><strong>注：</strong>不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同。</li></ul><h2 id="14-String-StringBuffer-StringBuilder的区别"><a href="#14-String-StringBuffer-StringBuilder的区别" class="headerlink" title="14.String,StringBuffer,StringBuilder的区别"></a>14.String,StringBuffer,StringBuilder的区别</h2><p><strong>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）</strong></p><ul><li><p>StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。</p></li><li><p>先说一下集合的故事，HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。</p></li></ul><h2 id="15-为什么会有基本类型包装类"><a href="#15-为什么会有基本类型包装类" class="headerlink" title="15.为什么会有基本类型包装类"></a>15.为什么会有基本类型包装类</h2><p><strong>基本类型的优势：数据存储相对简单，运算效率比较高。</strong><br><strong>包装类的优势：自带方法丰富，集合的元素必须是对象类型，体现了Java一切皆是对象的思想。</strong></p><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111114653964.png" alt=""></p><p>我们知道Java是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p><p>另外，当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。</p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pbjk5NjM1ODMxMi9hcnRpY2xlL2RldGFpbHMvNjI4OTQ2NzQ=" title="https://blog.csdn.net/min996358312/article/details/62894674"><i class="fa fa-fas fa-link"></i>点击进入《java中有了基本类型为什么还要有包装类型》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="16-自动装箱-拆箱"><a href="#16-自动装箱-拆箱" class="headerlink" title="16.自动装箱/拆箱"></a>16.自动装箱/拆箱</h2><p><strong>当上方表格中列出的基础类型与它们的包装类有如下几种情况时，编译器会自动帮我们进行装箱或拆箱。</strong></p><ul><li>进行 = 赋值操作（装箱或拆箱）</li><li>进行+，-，*，/混合运算 （拆箱）</li><li>进行&gt;,&lt;,==比较运算（拆箱）</li><li>调用equals进行比较（装箱）</li><li>ArrayList,HashMap等集合类 添加基础类型数据时（装箱）</li></ul><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1846487437001924" data-ad-slot="6405014372"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjUxODNlN2U1MWQ0NTE5MTI1MzFjYjU=" title="https://juejin.im/post/5b5183e7e51d451912531cb5"><i class="fa fa-fas fa-link"></i>点击进入《5分钟彻底理解-Java自动装箱、拆箱》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="17-数组和集合的区别，分别什么时候用"><a href="#17-数组和集合的区别，分别什么时候用" class="headerlink" title="17.数组和集合的区别，分别什么时候用"></a>17.数组和集合的区别，分别什么时候用</h2><ul><li>数组声明了它容纳的元素的类型，而集合不声明。</li><li>数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小，集合提供更多的成员方法，能满足更多的需求。</li><li>数组是大小固定的,一旦创建无法扩容;集合大小不固定。</li><li>数组的存放的类型只能是一种,集合存放的类型可以不是一种(不加泛型时添加的类型是Object)。</li><li>数组是java语言中内置的数据类型,是线性排列的,执行效率或者类型检查,都是最快的。ArrayList就是基于数组创建的容器类。</li><li>若程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array不适用。</li></ul><p><strong>使用相应的toArray()和Arrays.asList()方法可以相互转换。</strong></p><h2 id="18-Iterator和ListIterator的区别"><a href="#18-Iterator和ListIterator的区别" class="headerlink" title="18.Iterator和ListIterator的区别"></a>18.Iterator和ListIterator的区别</h2><p><strong>Iterator迭代器包含的方法有：</strong></p><ul><li>hasNext()：如果迭代器指向位置后面还有元素，则返回 true，否则返回false</li><li>next()：返回集合中Iterator指向位置后面的元素</li><li>remove()：删除集合中Iterator指向位置后面的元素</li></ul><p><strong>ListIterator迭代器包含的方法有：</strong></p><ul><li>add(E e): 将指定的元素插入列表，插入位置为迭代器当前位置之前</li><li>hasNext()：以正向遍历列表时，如果列表迭代器后面还有元素，则返回 true，否则返回false</li><li>hasPrevious():如果以逆向遍历列表，列表迭代器前面还有元素，则返回 true，否则返回false</li><li>next()：返回列表中ListIterator指向位置后面的元素</li><li>nextIndex():返回列表中ListIterator所需位置后面元素的索引</li><li>previous():返回列表中ListIterator指向位置前面的元素</li><li>previousIndex()：返回列表中ListIterator所需位置前面元素的索引</li><li>remove():从列表中删除next()或previous()返回的最后一个元素（有点拗口，意思就是对迭代器使用hasNext()方法时，删除ListIterator指向位置后面的元素；当对迭代器使用hasPrevious()方法时，删除ListIterator指向位置前面的元素）</li><li>set(E e)：从列表中将next()或previous()返回的最后一个元素返回的最后一个元素更改为指定元素e</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><strong>1.</strong>使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。</p><p><strong>2.</strong>ListIterator有add方法，可以向List中添加对象，而Iterator不能。</p><p><strong>3.</strong>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。</p><p><strong>4.</strong>ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</p><p><strong>5.</strong>都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。</p><h2 id="19-Java集合框架的基础接口有哪些？"><a href="#19-Java集合框架的基础接口有哪些？" class="headerlink" title="19.Java集合框架的基础接口有哪些？"></a>19.Java集合框架的基础接口有哪些？</h2><p><strong>总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用； HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好。</strong></p><p><strong>java.util.Collection [I]</strong><br></p><div class="note success no-icon"><ul><li><p>java.util.List [I]</p><ul><li>java.util.ArrayList [C]</li><li>java.util.LinkedList [C]</li><li>java.util.Vector [C]<ul><li>java.util.Stack [C]</li></ul></li></ul></li><li><p>java.util.Set [I]</p><ul><li>java.util.HashSet [C]</li><li>java.util.SortedSet [I]<ul><li>java.util.TreeSet [C]</li></ul></li></ul></li></ul></div><p></p><p><strong>java.util.Map [I]</strong><br></p><div class="note success no-icon"><ul><li>java.util.SortedMap [I]<ul><li>java.util.TreeMap [C]</li></ul></li><li>java.util.Hashtable [C]</li><li>java.util.HashMap [C]<ul><li>java.util.LinkedHashMap [C]</li></ul></li><li>java.util.WeakHashMap [C]</li></ul></div><p></p><h2 id="20-遍历一个List有哪些不同的方式？"><a href="#20-遍历一个List有哪些不同的方式？" class="headerlink" title="20.遍历一个List有哪些不同的方式？"></a>20.遍历一个List有哪些不同的方式？</h2><ul><li>普通for循环。</li><li>增强for循环（foreach）</li><li>迭代器（Iterator）</li></ul><h2 id="21-ArrayList、Vector、LinkedList的区别"><a href="#21-ArrayList、Vector、LinkedList的区别" class="headerlink" title="21.ArrayList、Vector、LinkedList的区别"></a>21.ArrayList、Vector、LinkedList的区别</h2><ul><li><p>ArrayList是一个可以处理变长数组的类型，可以存放任意类型的对象。ArrayList的所有方法都是默认在单一线程下进行的，因此ArrayList不具有线程安全性。</p></li><li><p>LinkedList可以看做为一个双向链表，LinkedList也是线程不安全的，在LinkedList的内部实现中，并不是用普通的数组来存放数据的，而是使用结点&lt; node &gt;来存放数据的，有一个指向链表头的结点first和一个指向链表尾的结点last。LinkedList的插入方法的效率要高于ArrayList，但是查询的效率要低一点。</p></li><li><p>Vector也是一个类似于ArrayList的可变长度的数组类型，它的内部也是使用数组来存放数据对象的。值得注意的是Vector与ArrayList唯一的区别是，Vector是线程安全的。在扩展容量的时候，Vector是扩展为原来的2倍，而ArrayList是扩展为原来的1.5倍。</p></li></ul><p><strong>线程安全</strong>就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p><p><strong>线程不安全</strong>就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><h2 id="22-栈和队列数据结构"><a href="#22-栈和队列数据结构" class="headerlink" title="22.栈和队列数据结构"></a>22.栈和队列数据结构</h2><p>栈 (Stack)是一种<strong>后进先出</strong>(last in first off，LIFO)的数据结构。<br>而队列(Queue)则是一种<strong>先进先出</strong> (fisrt in first out，FIFO)的结构。<br>如下图：<br><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111014345892.png" alt=""></p><h2 id="23-泛型好处"><a href="#23-泛型好处" class="headerlink" title="23.泛型好处"></a>23.泛型好处</h2><ul><li>把运行时期的错误转移到编译期。</li><li><strong>消除强制类型转换</strong>。 泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</li><li><strong>类型安全</strong>。 泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。</li><li><strong>潜在的性能收益</strong>。 泛型为较大的优化带来可能。在泛型的初始实现中，编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）插入生成的字节码中。但是更多类型信息可用于编译器这一事实，为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，编译器生成类似于没有泛型（和强制类型转换）时所写的代码，只是更能确保类型安全而已。</li></ul><h2 id="24-集合的三种迭代的能否删除元素"><a href="#24-集合的三种迭代的能否删除元素" class="headerlink" title="24.集合的三种迭代的能否删除元素"></a>24.集合的三种迭代的能否删除元素</h2><ul><li>普通for循环 可以删除元素但是每删除一个元素下标要–防止漏删。因为当元素被删除时，后面的元素会向前靠也就是下标会改变。</li><li>增强for循环（foreach） 不能删</li><li>迭代器 可以删除，只能使用迭代器的remove方法来删除</li></ul><h2 id="25-HashSet原理"><a href="#25-HashSet原理" class="headerlink" title="25.HashSet原理"></a>25.HashSet原理</h2><ul><li>我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数</li><li>当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象</li><li>如果没有哈希值相同的对象就直接存入集合</li><li>如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存</li></ul><p><strong>注：将自定义类的对象存入HashSet去重复，类中必须重写hashCode()和equals()方法。</strong></p><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。</p><p>HashSet中不允许有重复元素，这是因为HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();。HashSet跟HashMap一样，都是一个存放链表的数组。</p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW55dWVyZW5zaGVuZy9hcnRpY2xlL2RldGFpbHMvNTE1ODA2ODg=" title="https://blog.csdn.net/jianyuerensheng/article/details/51580688"><i class="fa fa-fas fa-link"></i>点击进入《【数据结构】HashSet原理及实现学习总结》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="26-TreeSet原理"><a href="#26-TreeSet原理" class="headerlink" title="26.TreeSet原理"></a>26.TreeSet原理</h2><ul><li>TreeSet是基于TreeMap实现的，同样的只是用key及其操作，然后把value置为dummy的object。</li><li>TreeSet是一个有序集合，TreeSet中的元素将按照升序排列，缺省是按照自然排序进行排列，意味着TreeSet中的元素要<strong>实现Comparable接口</strong>。或者有一个自定义的比较器。我们可以在构造TreeSet对象时，<strong>传递实现Comparator接口的比较器对象实例,</strong>。<br>例如：<br>Set<user2>setUser2 = new TreeSet&lt;&gt;(<strong>new User2()</strong>);</user2></li></ul><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111020910764.png" alt=""></p><h2 id="27-HashMap和Hashtable的区别"><a href="#27-HashMap和Hashtable的区别" class="headerlink" title="27.HashMap和Hashtable的区别"></a>27.HashMap和Hashtable的区别</h2><p><strong>HashMap 不是线程安全的。HashMap 是 map 接口的实现类，是将键映射到值的对象，其中键和值都是对象，并且不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。</strong></p><p><strong>HashTable 是线程安全 Collection。<br>HashMap 是 HashTable 的轻量级实现，他们都完成了Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。</strong></p><ul><li>HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li><li>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</li><li>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</li><li>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</li><li>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</li></ul><h2 id="28-throws和throw的区别"><a href="#28-throws和throw的区别" class="headerlink" title="28.throws和throw的区别"></a>28.throws和throw的区别</h2><ul><li>Throw用于方法内部，Throws用于方法声明上。</li><li>Throw后跟异常对象，Throws后跟异常类型。</li><li>Throw后只能跟一个异常对象，Throws后可以一次声明多种异常类型。</li></ul><h2 id="29-final-finally和finalize的区别"><a href="#29-final-finally和finalize的区别" class="headerlink" title="29.final,finally和finalize的区别"></a>29.final,finally和finalize的区别</h2><ul><li>final 用于申明属性，方法和类，表示属性不可变，方法不可以被覆盖，类不可以被继承。</li><li>finally 是异常处理语句结构中，表示总是执行的部分。</li><li>finallize 表示是object类一个方法，在垃圾回收机制中执行的时候会被调用被回收对象的方法。允许回收此前未回收的内存垃圾。所有object都继承了，finalize（）方法。</li></ul><h2 id="30-如果catch里面有return语句，请问finally的代码还会执行吗-如果会，请问是在return前还是return后？"><a href="#30-如果catch里面有return语句，请问finally的代码还会执行吗-如果会，请问是在return前还是return后？" class="headerlink" title="30.如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？"></a>30.如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？</h2><ul><li>不管有没有出现异常，finally块中代码都会执行；</li><li>当try和catch中有return时，finally仍然会执行；</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li><li>finally块的语句在try或catch中的return语句执行之后返回之前执行，且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。</li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFueHVlemFpcGlhby9wLzM0NDA0NzEuaHRtbA==" title="https://www.cnblogs.com/lanxuezaipiao/p/3440471.html"><i class="fa fa-fas fa-link"></i>点击进入《Java finally语句到底是在return之前还是之后执行？》<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2thdmVuc3UvYXJ0aWNsZS9kZXRhaWxzLzgwNjc4NTA=" title="https://blog.csdn.net/kavensu/article/details/8067850"><i class="fa fa-fas fa-link"></i>点击进入《有return的情况下try catch finally的执行顺序（最有说服力的总结）》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="31-是否可以继承String"><a href="#31-是否可以继承String" class="headerlink" title="31.是否可以继承String"></a>31.是否可以继承String</h2><p><strong>不可以，因为String类有final修饰符，而final修饰的类是不能被继承的，实现细节不允许改变。</strong></p><h2 id="32-break-、continue和return的区别"><a href="#32-break-、continue和return的区别" class="headerlink" title="32.break 、continue和return的区别"></a>32.break 、continue和return的区别</h2><ul><li>break只跳出当前for循环</li><li>continue是终止当前循环语句的执行，继续下一条循环语句。</li><li>return是结束当前方法的执行</li></ul><h2 id="33-异常分为哪些种类"><a href="#33-异常分为哪些种类" class="headerlink" title="33.异常分为哪些种类"></a>33.异常分为哪些种类</h2><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111025917752.png" alt=""></p><ul><li>Error类代表了编译和系统的错误，不允许捕获；</li><li>Exception类代表了标准Java库方法所激发的异常。<ul><li>Exception类还包含运行异常类Runtime_Exception和非运行异常类Non_RuntimeException这两个直接的子类。</li></ul></li></ul><h2 id="34-5个常见的RuntimeException"><a href="#34-5个常见的RuntimeException" class="headerlink" title="34.5个常见的RuntimeException"></a>34.5个常见的RuntimeException</h2><p>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException 不支持的操作异常<br>java.lang.StackOverflowError堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误<br>java.lang.ThreadDeath线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。<br>java.lang.ArithmeticException　“数学运算异常”，比如程序中出现了除以零这样的运算就会出这样的异常。</p><h2 id="35-switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？"><a href="#35-switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？" class="headerlink" title="35.switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？"></a>35.switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？</h2><ul><li>switch可作用于char byte short int</li><li>switch可作用于char byte short int对应的包装类</li><li>switch不可作用于long double float boolean，包括他们的包装类</li><li>switch中可以是字符串类型,String(jdk1.7之后才可以作用在string上)</li><li>switch中可以是枚举类型</li></ul><h2 id="36-String是基本数据类型么"><a href="#36-String是基本数据类型么" class="headerlink" title="36.String是基本数据类型么"></a>36.String是基本数据类型么</h2><p><strong>基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的</strong></p><p>String不是基本数据类型，而是一个类（class），是Java编程语言中的字符串。String对象是char的有序集合，并且该值是不可变的。因为java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。</p><p><strong>Java中的String是正宗的引用类型，但是，一定条件下，String会表现出一定的值特性。</strong></p><h2 id="37-short-s-1-s-s-1-有什么错？-s-1；-有什么错？"><a href="#37-short-s-1-s-s-1-有什么错？-s-1；-有什么错？" class="headerlink" title="37.short s = 1 ; s = s + 1;有什么错？ s += 1； 有什么错？"></a>37.short s = 1 ; s = s + 1;有什么错？ s += 1； 有什么错？</h2><p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型（默认为int），所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。<br>对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p><p><strong>隐式转换</strong></p><ul><li>特征：从小到大，可以隐式转换，数据类型将自动提升。<br>byte，short，char –&gt;int –&gt;long –&gt;float –&gt;double<br>注意：long是8个字节，float是4个字节。<br>long是整数，float是浮点型，整数和浮点数的存储规则不一样，记住一点long的范围是小于float的。<br>例 :<br>byte a=10;<br>int b=a;<br>当编译intb=a 时， a隐式转换为int类型。</li><li>在使用 =，+=，-=，*=，/= , %= 时隐含有数据类型的转换。</li></ul><h2 id="38-String类常用的方法有哪些？"><a href="#38-String类常用的方法有哪些？" class="headerlink" title="38.String类常用的方法有哪些？"></a>38.String类常用的方法有哪些？</h2><ul><li>int length() 返回此字符串的长度。</li><li>charAt(int index) 返回指定索引处的 char 值。</li><li>int compareTo(Object o) 把这个字符串和另一个对象比较。</li><li>String concat(String str) 将指定字符串连接到此字符串的结尾。</li><li>int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。</li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9qYXZhL2phdmEtc3RyaW5nLmh0bWw=" title="https://www.runoob.com/java/java-string.html"><i class="fa fa-fas fa-link"></i>点击进入《Java String 类》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="39-Integer-a-200-Integer-b-200-System-out-println-a-b-执行结果是true还是false？"><a href="#39-Integer-a-200-Integer-b-200-System-out-println-a-b-执行结果是true还是false？" class="headerlink" title="39.Integer a = 200; Integer b = 200 ; System.out.println(a == b);执行结果是true还是false？"></a>39.Integer a = 200; Integer b = 200 ; System.out.println(a == b);执行结果是true还是false？</h2><p><strong>在Object类中中，equals()和”==”是等价的，但是在大部分的包装类中，都重写了equals()方法，所以两者还是有区别的。总的来说”==”是一个关系运算符，如果比较的两端都为原生数据类型，则表示判断两者的值是否相等，如果比较的两端都为引用类型，则比较两者所指向对象的地址是否相同；对于equals()方法，如果这个对象所在的类重写了equals方法，则按照重写的方法进行比较，如果没有，则比较两者所指向对象的地址是否相同,其实就是使用”==”进行比较。</strong></p><p>在-128-127之间，a和b都没有new成一个新的对象，可以直接把值进行比较，如果不在这个范围，则new一个新的Integer对象并返回。查看Integer类的源码可以发现，这个数组里面缓存了基本类型-128-127之间的Integer对象。但是由于是两个new出来的对象（引用类型）做比较，所以==肯定返回的false。</p><h2 id="40-字节流如何转成字符流？"><a href="#40-字节流如何转成字符流？" class="headerlink" title="40.字节流如何转成字符流？"></a>40.字节流如何转成字符流？</h2><p><strong>将字节流转换成字符流的桥梁——InputStreamReader；</strong></p><ul><li>InputStreamReader(InputStream in) ：创建一个使用默认字符集的 InputStreamReader。传入的对象是InputStream类型，而自己本身是Reader的子类。</li></ul><p><strong>将字符流转换成字节流的桥梁——OutputStreamWriter。</strong></p><ul><li>OutputStreamWriter(OutputStream out) ：创建使用默认字符编码的 OutputStreamWriter。传入的对象是OutputStream类型，而自己本身是Writer的子类。</li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3B1cHB5bHBnL2FydGljbGUvZGV0YWlscy80NTYyMDM4Nw==" title="https://blog.csdn.net/puppylpg/article/details/45620387"><i class="fa fa-fas fa-link"></i>点击进入《Java 字节流 字符流 转换流》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="41-java中有几种类型的流"><a href="#41-java中有几种类型的流" class="headerlink" title="41.java中有几种类型的流"></a>41.java中有几种类型的流</h2><p>字节流和字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于Java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。</p><h2 id="42-字节流和字符流的区别"><a href="#42-字节流和字符流的区别" class="headerlink" title="42.字节流和字符流的区别"></a>42.字节流和字符流的区别</h2><p>Java中的<strong>字节流</strong>处理的最基本单位为单个字节，它通常用来处理二进制数据。Java中最基本的两个字节流类是InputStream和OutputStream，它们分别代表了组基本的输入字节流和输出字节流。InputStream类与OutputStream类均为抽象类，我们在实际使用中通常使用Java类库中提供的它们的一系列子类。</p><p>Java中的<strong>字符流</strong>处理的最基本的单元是Unicode码元（大小2字节），它通常用来处理文本数据。所谓Unicode码元，也就是一个Unicode代码单元，范围是0x0000~0xFFFF。在以上范围内的每个数字都与一个字符相对应，Java中的String类型默认就把字符以Unicode规则编码而后存储在内存中。然而与存储在内存中不同，存储在磁盘上的数据通常有着各种各样的编码方式。使用不同的编码方式，相同的字符会有不同的二进制表示。实际上字符流是这样工作的：</p><ul><li>输出字符流：把要写入文件的字符序列（实际上是Unicode码元序列）转为指定编码方式下的字节序列，然后再写入到文件中；</li><li>输入字符流：把要读取的字节序列按指定编码方式解码为相应字符序列（实际上是Unicode码元序列从）从而可以存在内存中。</li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWJzZnJlZS9wLzU0MTUwOTIuaHRtbA==" title="https://www.cnblogs.com/absfree/p/5415092.html"><i class="fa fa-fas fa-link"></i>点击进入《理解Java中字符流与字节流的区别》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="43-如何跳出多重嵌套循环，继续执行后面的代码？"><a href="#43-如何跳出多重嵌套循环，继续执行后面的代码？" class="headerlink" title="43.如何跳出多重嵌套循环，继续执行后面的代码？"></a>43.如何跳出多重嵌套循环，继续执行后面的代码？</h2><p>在java中，使用break可以跳出循环，默认情况下是跳出最里层的循环，假如我们要跳出多层循环怎么办呢，Java替我们已经做好了这一点，就是用 循环标签 ：即是对某个循环定义一个名字，然后在 break 后面加上这个名字，当符合 break 条件时，程序就会跳到规定的循环那。<br></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">		lableB:</span><br><span class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">			lableA:</span><br><span class="line">			<span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">				System.out.<span class="built_in">println</span>(j);</span><br><span class="line">				<span class="built_in">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">break</span> lableB;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"over!"</span>);</span><br></pre></td></tr></table></figure><p></p><p><strong>注：<br>标签名的命名方法是：java命名规则 和 半角冒号 比如： lableA:<br>PS：lableB标签的定义需要在使用break lableB语句之前定义。<br>break只跳出当前for循环<br>return是结束当前方法的执行<br>continue是终止当前循环语句的执行，继续下一条循环语句。</strong></p><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1846487437001924" data-ad-slot="6405014372"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h2 id="44-异常的父类"><a href="#44-异常的父类" class="headerlink" title="44.异常的父类"></a>44.异常的父类</h2><p><strong>Throwable是所有异常类的根类，也就是说所有异常类都继承于它。</strong></p><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111034905630.png" alt=""></p><h2 id="45-线程的生命周期"><a href="#45-线程的生命周期" class="headerlink" title="45.线程的生命周期"></a>45.线程的生命周期</h2><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111035107425.png" alt=""></p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3VuZGRlbmx5L3AvNDEwNjU2Mi5odG1s" title="https://www.cnblogs.com/sunddenly/p/4106562.html"><i class="fa fa-fas fa-link"></i>点击进入《线程生命周期》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="46-线程的实现方式有哪些"><a href="#46-线程的实现方式有哪些" class="headerlink" title="46.线程的实现方式有哪些"></a>46.线程的实现方式有哪些</h2><ul><li>方法1： extends Thread ,重写run方法</li><li>方法2： implements Runnable ，实现 run方法</li><li>方法3：implements Callable，实现call方法</li></ul><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111035736601.png" alt=""></p><h2 id="47-线程怎么通信"><a href="#47-线程怎么通信" class="headerlink" title="47.线程怎么通信"></a>47.线程怎么通信</h2><ul><li>利用共享对象实现通信<ul><li>忙等（busy waiting）</li><li>wait(), notify() and notifyAll()</li><li>信号丢失（Missed Signals）</li><li>虚假唤醒（Spurious Wakeups）</li><li>多个线程等待相同的信号</li><li>不要对String对象或者全局对象调用wait方法</li></ul></li></ul><p><strong>线程通信的目的就是让线程间具有互相发送信号通信的能力。<br>而且，线程通信可以实现，一个线程可以等待来自其他线程的信号。举个例子，一个线程B可能正在等待来自线程A的信号，这个信号告诉线程B数据已经处理好了。</strong></p><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111040013863.png" alt=""></p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81YjlmZGFlNDMzMzU=" title="https://www.jianshu.com/p/5b9fdae43335"><i class="fa fa-fas fa-link"></i>点击进入《Java线程通信（Thread Signaling）》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="48-线程中wait和sleep方法的区别"><a href="#48-线程中wait和sleep方法的区别" class="headerlink" title="48.线程中wait和sleep方法的区别"></a>48.线程中wait和sleep方法的区别</h2><p><strong>wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，当一个线程调用wait()方法的时候，会释放它锁持有的对象的管程（monitors）和锁，但是调用sleep()方法的时候，不会释放他所持有的管程。</strong></p><p><strong>注</strong>：在多线程访问共享资源的时候，经常会带来可见性和原子性的安全问题。为了解决这类线程安全的问题，Java提供了同步机制、互斥锁机制，这个机制保证了在同一时刻只有一个线程能访问共享资源。这个机制的保障来源于监视锁Monitor，每个对象都拥有自己的监视锁Monitor。</p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNWU5NTkwMzdlZWQ=" title="https://www.jianshu.com/p/25e959037eed"><i class="fa fa-fas fa-link"></i>点击进入《Java中Wait、Sleep和Yield方法的区别》<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9sbGlzY2h1YW5nLmNvbS9hcmNoaXZlcy8yMDMw" title="https://www.hollischuang.com/archives/2030"><i class="fa fa-fas fa-link"></i>点击进入《深入理解多线程（四）—— Moniter的实现原理》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="49-什么是线程池？如何使用？"><a href="#49-什么是线程池？如何使用？" class="headerlink" title="49.什么是线程池？如何使用？"></a>49.什么是线程池？如何使用？</h2><p><strong>java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</strong></p><p><img src="https://img.lee1224.com/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/20191111041158046.png" alt=""></p><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTgwODg5Nw==" title="https://segmentfault.com/a/1190000015808897"><i class="fa fa-fas fa-link"></i>点击进入《如何优雅的使用和理解线程池》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="50-常用的线程池有哪些？"><a href="#50-常用的线程池有哪些？" class="headerlink" title="50.常用的线程池有哪些？"></a>50.常用的线程池有哪些？</h2><ul><li>newFixedThreadPool<ul><li>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<runnable>() 无解阻塞队列</runnable></li><li>通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</li><li>适用：执行长期的任务，性能好很多</li></ul></li><li>newSingleThreadExecutor<ul><li>底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<runnable>() 无解阻塞队列</runnable></li><li>通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</li><li>适用：一个任务一个任务执行的场景</li></ul></li></ul><blockquote class="blockquote-center"><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE5NzQ5ODcvYXJ0aWNsZS9kZXRhaWxzLzUxMDI3Nzk1" title="https://blog.csdn.net/u011974987/article/details/51027795"><i class="fa fa-fas fa-link"></i>点击进入《Java 四种线程池的用法分析》<i class="fa fa-external-link"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cwNTk4MDU5OC9hcnRpY2xlL2RldGFpbHMvNzk0MjUwNzE=" title="https://blog.csdn.net/w05980598/article/details/79425071"><i class="fa fa-fas fa-link"></i>点击进入《Java线程池种类、区别和适用场景》<i class="fa fa-external-link"></i></span></p></blockquote><h2 id="51-启动线程是用run-还是用start-？"><a href="#51-启动线程是用run-还是用start-？" class="headerlink" title="51.启动线程是用run()还是用start()？"></a>51.启动线程是用run()还是用start()？</h2><p><strong>启动线程是用start()</strong></p><ul><li><p>start（）方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码：<br>通过调用Thread类的start()方法来启动一个线程，<br>这时此线程是处于就绪状态，<br>并没有运行。<br>然后通过此Thread类调用方法run()来完成其运行操作的，<br>这里方法run()称为线程体，<br>它包含了要执行的这个线程的内容，<br>Run方法运行结束，<br>此线程终止，<br>而CPU再运行其它线程。</p></li><li><p>run（）方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码：<br>而如果直接用Run方法，<br>这只是调用一个方法而已，<br>程序中依然只有主线程–这一个线程，<br>其程序执行路径还是只有一条，<br>这样就没有达到写线程的目的。</p></li></ul><p>注：<br><strong>Thread和Runnable的区别</strong>：<br>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br>实现Runnable接口比继承Thread类所具有的优势：</p><p>1）：适合多个相同的程序代码的线程去处理同一个资源</p><p>2）：可以避免java中的单继承的限制</p><p>3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。</p><h2 id="52-线程和进程的区别"><a href="#52-线程和进程的区别" class="headerlink" title="52.线程和进程的区别"></a>52.线程和进程的区别</h2><ul><li>地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li>线程的改变只代表了 CPU 执行过程的改变，而没有发生进程所拥有的资源变化。</li><li>计算机内的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源。</li><li>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</li><li>子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。多线程主要是为了节约CPU时间，发挥利用，根据具体情况而定。线程的运行中需要使用计算机的内存资源和CPU。</li></ul><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-1846487437001924" data-ad-slot="6405014372"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p><strong>注：</strong><br><strong>线程</strong>：一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。线程之间共用一个进程的内存空存空间。</p><p>通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。（线程之间共用一个进程的内存空存空间）在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度。</p><h2 id="53-并发和并行的区别是什么？"><a href="#53-并发和并行的区别是什么？" class="headerlink" title="53.并发和并行的区别是什么？"></a>53.并发和并行的区别是什么？</h2><ul><li><strong>并发</strong>是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</li><li><strong>并行</strong>就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</li></ul></div><div style="text-align:center;font-size:13px;letter-spacing:10px;user-select:none;margin-top:50px;color:#bbb">本文结束啦 <i class="fa fa-paw"></i> 感谢您阅读</div><div><div id="music163player" style="margin-top:17px"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=429769189&auto=1&height=32"></iframe></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1846487437001924" data-ad-slot="1867469182" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>路漫漫其修远兮 吾将上下而求索</div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="https://img.lee1224.com/wechatpay.png" alt="黎雁鹏 微信支付"><p>微信支付</p></div><div id="qqpay" style="display:inline-block"><img id="qqpay_qr" src="https://img.lee1224.com/qqpay.png" alt="黎雁鹏 QQ钱包"><p>QQ钱包</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="https://img.lee1224.com/alipay.png" alt="黎雁鹏 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java基础/" rel="tag"><i class="fa fa-tag"></i> Java基础</a> <a href="/tags/Java常见面试题/" rel="tag"><i class="fa fa-tag"></i> Java常见面试题</a></div><div class="post-widgets"><div class="social_share"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/ShadowsocksRjc/" rel="next" title="酸酸乳ssr教程与免费节点分享"><i class="fa fa-chevron-left"></i> 酸酸乳ssr教程与免费节点分享</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="https://img.lee1224.com/avatar.png" alt="黎雁鹏"><p class="site-author-name" itemprop="name">黎雁鹏</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">26</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">74</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RwMTIyNA==" title="GitHub &rarr; https://github.com/dp1224"><i class="fa fa-fw fa-github"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOjczMTcyNzMxM0BxcS5jb20=" title="E-Mail &rarr; mailto:731727313@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20vbGVlNzMxNzI3MzEz" title="Weibo &rarr; https://weibo.com/lee731727313"><i class="fa fa-fw fa-weibo"></i>Weibo</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9kcC5sZWU=" title="Instagram &rarr; https://www.instagram.com/dp.lee"><i class="fa fa-fw fa-instagram"></i>Instagram</span></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、Java基础部分"><span class="nav-text">一、Java基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-基本数据类型以及字节数"><span class="nav-text">1.基本数据类型以及字节数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-标识符命名规则"><span class="nav-text">2.标识符命名规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-方法重写和重载的区别"><span class="nav-text">3.方法重写和重载的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#重写-Override-方法的重写规则"><span class="nav-text">重写(Override)方法的重写规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载-Overload"><span class="nav-text">重载(Overload)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载规则"><span class="nav-text">重载规则:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-面向对象的特性，以及你是怎么理解的？-面向对象三大特性，五大基本原则"><span class="nav-text">4.面向对象的特性，以及你是怎么理解的？(面向对象三大特性，五大基本原则)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-访问修饰符-public、private、protected、以及不写时的区别"><span class="nav-text">5.访问修饰符 public、private、protected、以及不写时的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-子类继承父类，静态代码块、构造代码块、构造函数的执行顺序"><span class="nav-text">6.子类继承父类，静态代码块、构造代码块、构造函数的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-amp-和-amp-amp-的区别"><span class="nav-text">7.&amp; 和 &amp;&amp; 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-什么是抽象类"><span class="nav-text">8.什么是抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？"><span class="nav-text">9.一个抽象类没有抽象方法，可不可以定义为抽象类？如果可以，有何意义？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-abstract不能和哪些关键字共存，为什么？"><span class="nav-text">10.abstract不能和哪些关键字共存，为什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-抽象类和接口的区别"><span class="nav-text">11.抽象类和接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-什么是匿名内部类"><span class="nav-text">12.什么是匿名内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-号和equals方法的区别"><span class="nav-text">13.==号和equals方法的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-String-StringBuffer-StringBuilder的区别"><span class="nav-text">14.String,StringBuffer,StringBuilder的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-为什么会有基本类型包装类"><span class="nav-text">15.为什么会有基本类型包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-自动装箱-拆箱"><span class="nav-text">16.自动装箱/拆箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-数组和集合的区别，分别什么时候用"><span class="nav-text">17.数组和集合的区别，分别什么时候用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-Iterator和ListIterator的区别"><span class="nav-text">18.Iterator和ListIterator的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不同点"><span class="nav-text">不同点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-Java集合框架的基础接口有哪些？"><span class="nav-text">19.Java集合框架的基础接口有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-遍历一个List有哪些不同的方式？"><span class="nav-text">20.遍历一个List有哪些不同的方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-ArrayList、Vector、LinkedList的区别"><span class="nav-text">21.ArrayList、Vector、LinkedList的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-栈和队列数据结构"><span class="nav-text">22.栈和队列数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-泛型好处"><span class="nav-text">23.泛型好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-集合的三种迭代的能否删除元素"><span class="nav-text">24.集合的三种迭代的能否删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-HashSet原理"><span class="nav-text">25.HashSet原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-TreeSet原理"><span class="nav-text">26.TreeSet原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-HashMap和Hashtable的区别"><span class="nav-text">27.HashMap和Hashtable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-throws和throw的区别"><span class="nav-text">28.throws和throw的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-final-finally和finalize的区别"><span class="nav-text">29.final,finally和finalize的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-如果catch里面有return语句，请问finally的代码还会执行吗-如果会，请问是在return前还是return后？"><span class="nav-text">30.如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-是否可以继承String"><span class="nav-text">31.是否可以继承String</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-break-、continue和return的区别"><span class="nav-text">32.break 、continue和return的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-异常分为哪些种类"><span class="nav-text">33.异常分为哪些种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-5个常见的RuntimeException"><span class="nav-text">34.5个常见的RuntimeException</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？"><span class="nav-text">35.switch是否可以作用在byte上？是否可以作用在long上？是否可以作用在String上？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-String是基本数据类型么"><span class="nav-text">36.String是基本数据类型么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-short-s-1-s-s-1-有什么错？-s-1；-有什么错？"><span class="nav-text">37.short s = 1 ; s = s + 1;有什么错？ s += 1； 有什么错？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-String类常用的方法有哪些？"><span class="nav-text">38.String类常用的方法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-Integer-a-200-Integer-b-200-System-out-println-a-b-执行结果是true还是false？"><span class="nav-text">39.Integer a = 200; Integer b = 200 ; System.out.println(a == b);执行结果是true还是false？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-字节流如何转成字符流？"><span class="nav-text">40.字节流如何转成字符流？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-java中有几种类型的流"><span class="nav-text">41.java中有几种类型的流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-字节流和字符流的区别"><span class="nav-text">42.字节流和字符流的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-如何跳出多重嵌套循环，继续执行后面的代码？"><span class="nav-text">43.如何跳出多重嵌套循环，继续执行后面的代码？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-异常的父类"><span class="nav-text">44.异常的父类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-线程的生命周期"><span class="nav-text">45.线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-线程的实现方式有哪些"><span class="nav-text">46.线程的实现方式有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-线程怎么通信"><span class="nav-text">47.线程怎么通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-线程中wait和sleep方法的区别"><span class="nav-text">48.线程中wait和sleep方法的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-什么是线程池？如何使用？"><span class="nav-text">49.什么是线程池？如何使用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-常用的线程池有哪些？"><span class="nav-text">50.常用的线程池有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-启动线程是用run-还是用start-？"><span class="nav-text">51.启动线程是用run()还是用start()？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-线程和进程的区别"><span class="nav-text">52.线程和进程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-并发和并行的区别是什么？"><span class="nav-text">53.并发和并行的区别是什么？</span></a></li></ol></li></ol></div></div></div><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div><div style="margin-top:22px"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-1846487437001924" data-ad-slot="7544259708" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"><span class="exturl" data-url="aHR0cDovL3d3dy5taWl0YmVpYW4uZ292LmNu">蜀ICP备18031030号-2 </span>&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love" id="animate"><i class="fa fa-spinner"></i> </span><span class="author" itemprop="copyrightHolder">黎雁鹏</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div><script>window._bd_share_config={common:{bdText:"",bdMini:"1",bdMiniList:!1,bdPic:""},image:{viewList:["tsina","douban","sqq","qzone","weixin","twi","fbook"],viewText:"分享到：",viewSize:"16"},slide:{bdImg:"5",bdPos:"left",bdTop:"100"}}</script><script>with(document)0[(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="/static/api/js/share.js?v=89860593.js?cdnversion="+~(-new Date/36e5)]</script></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/three/three.min.js"></script><script src="/lib/three/three-waves.min.js"></script><script src="/lib/reading_progress/reading_progress.js"></script><script src="/js/src/utils.js?v=6.6.0"></script><script src="/js/src/motion.js?v=6.6.0"></script><script src="/js/src/affix.js?v=6.6.0"></script><script src="/js/src/schemes/pisces.js?v=6.6.0"></script><script src="/js/src/scrollspy.js?v=6.6.0"></script><script src="/js/src/post-details.js?v=6.6.0"></script><script src="/js/src/bootstrap.js?v=6.6.0"></script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={},pbOptions.iconStyle="box",pbOptions.boxForm="horizontal",pbOptions.position="bottomCenter",pbOptions.networks="Weibo,Wechat,Douban,QQZone,Twitter,Facebook",new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script src="/js/src/exturl.js?v=6.6.0"></script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length);var d=document.execCommand("copy");d?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script><script type="text/javascript" src="/js/src/crash_cheat.js"></script></body></html><!-- rebuild by neat -->